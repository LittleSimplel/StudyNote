### 为什么要学 JVM

- 面试的需要：入职 BATJ、TMD、PKQ 等一线大厂不光关注技术的广度，更关注 技术的深度，JVM 技术是大厂面试的必备技能，掌握越深越好 
- 中高级程序员、架构师必备技能：架构师每天都在思考如何让我的系统更快， 如何避免系统出现性能瓶颈。单纯的依靠物理机不足以解决问题，分析系统 性能、调优系统瓶颈离不了对 JVM 中内存、垃圾回收、字节码指令、性能监 控工具、调优参数的熟练掌握。 
-  精进技术、极客追求：JVM 是 Java 生态的核心价值的体现，垃圾回收算法、 JIT、底层原理值得每个程序员去探索。同时，JVM 作为跨语言的平台，对于 深入理解 Scala、Kotlin、JavaScript、Jython、Groovy 也很有帮助。 

### jvm相关问题

- 运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM！ 
-  想解决线上 JVM GC 问题，但却无从下手。
-  新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧，然后就 JJ 了 
-  每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试 官却经常问你在实际项目中如何调优 JVM 参数，如何解决 GC、OOM 等问 题，一脸懵逼。 

 ### jvm介绍

#### java：跨平台语言

![第01章_Java语言的跨平台性](D:\study\github\StudyNote\jvm\img\JVM上篇配图\第01章_Java语言的跨平台性.jpg)

#### jvm：跨语言平台

![第01章_JVM跨语言的平台](D:\study\github\StudyNote\jvm\img\JVM上篇配图\第01章_JVM跨语言的平台.jpg)

#### vm和jvm

所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

1. 大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。
2. 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。
3. 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中

#### Java 虚拟机

1. Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。
2. JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。
3. Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。
4. Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。

**特点：**

1. 一次编译，到处运行
2. 自动内存管理
3. 自动垃圾回收功能

#### Java 的整体结构

1. HotSpot VM是目前市面上高性能虚拟机的代表作之一。
2. 它采用**解释器与即时编译器并存的架构**。
3. 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++程序一较高下的地步。
4. **执行引擎包含三部分：解释器，即时编译器，垃圾回收器**

![第02章_JVM架构-简图](D:\study\github\StudyNote\jvm\img\JVM上篇配图\第02章_JVM架构-简图.jpg)

#### Java 代码执行流程

1. 操作系统只能识别机器指令。
2. Jit 编译器 缓存热点数据，保证性能。

![jvm执行流程](D:\study\github\StudyNote\jvm\img\JVM上篇配图\jvm执行流程.png)

#### JVM 架构模型

**ava编译器输入的指令流基本上是一种基于栈的指令集架构**，另外一种指令集架构则是基于寄存器的指令集架构。具体来说：这两种架构之间的区别：

**基于栈式架构的特点：**

1. 设计和实现更简单，适用于资源受限的系统；（机顶盒，打印机）
2. **避开了寄存器的分配难题：使用零地址指令方式分配**
3. 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。**指令集更小，编译器容易实现**
4. **不需要硬件支持，可移植性更好，更好实现跨平台**

**基于寄存器架构的特点：**

1. 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
2. **指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差**
3. 性能优秀和执行更高效
4. 花费更少的指令去完成一项操作
5. 在大部分情况下，**基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主**，而基于栈式架构的指令集却是以零地址指令为主

**两种架构的举例**

同样执行2+3这种逻辑操作，其指令分别如下：

- **基于栈的计算流程（以Java虚拟机为例）：**

```
iconst_2 //常量2入栈
istore_1
iconst_3 // 常量3入栈
istore_2
iload_1
iload_2
iadd //常量2/3出栈，执行相加
istore_0 // 结果5入栈
12345678
```

- **而基于寄存器的计算流程**

```bash
mov eax,2 //将eax寄存器的值设为1
add eax,3 //使eax寄存器的值加3
```

#### JVM 架构总结

1. **由于跨平台性的设计，Java的指令都是根据栈来设计的**。不同平台CPU架构不同，所以不能设计为基于寄存器的。**优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令**
2. 时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？
3. 因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构