# 1 分布式用户会话管理

## 1.1 用户会话

用户会话是指具有唯一访问者标识(唯一地址)的访问者进入或再次进入网站的过程。为了保证再次进入网站是同一个用户，必须对用户会话进行管理，保存其登陆信息，通常的会话技术有两种：

- 客户端会话技术：Cookie

- 服务器端会话技术：Session

## 1.2 cookie作用域

`Cookie`是由服务器端生成，发送给`User-Agent`（一般是浏览器），（服务器告诉浏览器设置一下`cookie`），浏览器自动会将`Cookie`以`key/value`保存到某个目录下的文本文件内，下次请求同一网站时也会自动发送该`Cookie`给服务器，即添加在请求头部（前提是浏览器设置为启用`cookie`）。
`Cookie`就是一个小型文件（浏览器对`cookie`的内存大小（4k）是有限制的-------用来记录一些信息）

**作用域：**domain，path

- domain ：可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”。

- path：Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”和其子目录的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/”。

## 1.3 分布式下用户会话问题

1. 浏览器：不能跨不同域名共享。
2. 服务端：在冗余服务中，用户信息只存在一个服务上，服务之间未共享。

## 1.4 用户会话管理方式

- cookie + session
- 请求头+token(标识，用户登陆信息存在服务端)
- 请求头+jwt （用户登陆信息存在客户端）

## 1.5 分布式session 解决方案

### 1.5.1 Session共享问题解决-session复制

![image-20201111104851977](D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111104851977.png)

### 1.5.2 Session共享问题解决-客户端存储

![image-20201111104913888](D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111104913888.png)

### 1.5.3 Session共享问题解决-hash一致性

![image-20201111105039741](D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111105039741.png)

### 1.5.4 Session共享问题解决-统一存储

![image-20201111105135178](D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111105135178.png)

## 1.6 spring session

整合SpringBoot

### 16.1 添加Pom.xml依赖

```xml
 <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
 </dependency>
 <dependency>
        	<groupId>org.springframework.boot</groupId>
        	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

### 1.6.2 application.yml 配置

<img src="D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111145601673.png" alt="image-20201111145601673" style="zoom:67%;" />

### 1.6.3 reids配置

<img src="D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111150056671.png" alt="image-20201111150056671" style="zoom:69%;" />

### 1.6.4 启动类加注解

```java
@EnableRedisHttpSession // 整合spring session
```

### 1.6.5 自定义 SpringSession 完成 Session 子域共享

- `CookieSerializer`

  文档参考：https://docs.spring.io/spring-session/docs/2.4.1/reference/html5/index.html#api-cookieserializer

- `RedisSerializer`

  文档参考：https://docs.spring.io/spring-session/docs/2.4.1/reference/html5/index.html#api-redisindexedsessionrepository-config

  官网文档地址：https://docs.spring.io/spring-session/docs/2.4.1/reference/html5/index.html#samples

  提供的实例：

  https://github.com/spring-projects/spring-session/blob/2.4.1/spring-session-samples/spring-session-sample-boot-redis-json/src/main/java/sample/config/SessionConfig.java

```java
/**
 * SpringSession整合子域
 * 以及redis数据存储为json
 * @author gcq
 * @Create 2020-11-11
 */
@Configuration
public class GulimallSessionConfig {

    /**
     * 设置cookie信息
     * @return
     */
    @Bean
    public CookieSerializer CookieSerializer(){
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        // 设置一个域名的名字   
        //扩大 session的作用域至**.zyd.com
        // cookieSerializer.setDomainName(".zyd.com"); **.zyd.com 共享
        cookieSerializer.setDomainName("zyd.com");
        // cookie的路径
        cookieSerializer.setCookieName("FIRESESSION");
        return cookieSerializer;
    }

    /**
     * 设置json转换
     * @return
     */
    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        // 使用jackson提供的转换器
        return new GenericJackson2JsonRedisSerializer();
    }

}
```

### 1.6.7 SpringSession 原理 

https://blog.csdn.net/m0_46539364/article/details/110533408

```java
/**
 * 核心原理
 * 1、@EnableRedisHttpSession导入RedisHttpSessionConfiguration配置
 *      1、给容器中添加了一个组件
 *          sessionRepository = 》》》【RedisOperationsSessionRepository】 redis 操作 session session的增删改查封装类
 *      2、SessionRepositoryFilter==>:session存储过滤器，每个请求过来必须经过Filter
 *          1、创建的时候，就自动从容器中获取到了SessionRepostiory
 *          2、原始的request,response都被包装了 SessionRepositoryRequestWrapper、SessionRepositoryResponseWrapper
 *          3、以后获取session.request.getSession()
 *              SessionRepositoryResponseWrapper
 *          4、wrappedRequest.getSession() ==>SessionRepository
 *
 *          装饰者模式
 *          spring-redis的相关功能:
 *                 执行session相关操作后，redis里面存储的时间也会刷新
 */
```

核心源码是：

- `SessionRepositoryFilter` 类下面的 `doFilterInternal` 方法

- 及那个 `request`、`response` 包装成 `SessionRepositoryRequestWrapper`

  ![image-20201111195249024](D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201111195249024.png)

# 2 单点登录

上面解决了同域名的session问题，但如果`taobao.com`和`tianmao.com`这种不同的域名也想共享session呢？

https://www.jianshu.com/p/75edcc05acfd

## 2.1 代码实现单点登陆思路

**角色：a系统，b系统，sso server**

- a系统 或 b系统

  ```java
  @GetMapping(value = "/employees") 
  public String employees(Model model,
                          HttpSession session,
                          @RequestParam(value = "redisKey", required = false) String redisKey) {
  
      // 有loginToken这个参数，代表去过server端登录过了，server端里在redis里保存了个对象，而key:uuid给你发过来了
      // 有loginToken这个参数的话代表是从登录页跳回来的，而不是系统a直接传过来的
      // 你再拿着uuid再去查一遍user object，返回后设置到当前的系统session里
      // 提个问题：为什么当时不直接返回user对象，而是只返回个uuid？其实也可以，但是参数的地方也得是required = false。可能也有一些安全问题
      if (!StringUtils.isEmpty(redisKey)) { // 这个逻辑应该写到过滤器或拦截器里
          RestTemplate restTemplate=new RestTemplate();
          // 拿着token去服务器，在服务端从redis中查出来他的username
          ResponseEntity<Object> forEntity =
          restTemplate.getForEntity("http://ssoserver.com:8080/userInfo?redisKey="+ redisKey, Object.class);
  
          Object loginUser = forEntity.getBody();
          // 设置到自己的session中
          session.setAttribute("loginUser", loginUser);
      }
      // session里有就代表登录过 // 获得user
      Object loginUser = session.getAttribute("loginUser");
  
      if (loginUser == null) { // 又没有loginToken，session里又没有object，去登录页登录
          return "redirect:" + "http://ssoserver.com:8080/login.html"
              + "?url=http://clientA.com/employees";
      } else {// 登录过，执行正常的业务
       
      }
  }
  ```

  ##### server端

  ```java
  @Controller
  public class LoginController {
  
  	@Autowired
  	private StringRedisTemplate stringRedisTemplate;
  
  	@ResponseBody
  	@GetMapping("/userInfo") 
      // 得到redis中的存储过的user信息，返回给子系统的session中
  	public Object userInfo(@RequestParam("redisKey") String redisKey){
  		// 拿着其他域名转发过来的token去redis里查
  		Object loginUser = stringRedisTemplate.opsForValue().get(redisKey);
  		return loginUser;
  	}
  
      // 子系统都来这
  	@GetMapping("/login.html") 
  	public String loginPage(@RequestParam("url") String url,
  							Model model,
  							@CookieValue(value = "redisKey", required = false) String redisKey) {
  		// 非空代表就登录过了
  		if (!StringUtils.isEmpty(redisKey)) {
  			// 告诉子系统他的redisKey，拿着该token就可以查redis了
  			return "redirect:" + url + "?redisKey=" + redisKey;
  		}
  		model.addAttribute("url", url);
  
  		// 子系统都没登录过才去登录页
  		return "login";
  	}
  
      // server端统一认证
  	@PostMapping("/doLogin") 
  	public String doLogin(@RequestParam("username") String username,
  						  @RequestParam("password") String password,
  						  HttpServletResponse response,
  						  @RequestParam(value="url",required = false) String url){
  		// 确认用户后，生成cookie、redis中存储 // if内代表取查完数据库了
  		if(!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password)){//简单认为登录正确
  			// 登录成功跳转 跳回之前的页面
  			String redisKey = UUID.randomUUID().toString().replace("-", "");
  			// 存储cookie， 是在server.com域名下存
  			Cookie cookie = new Cookie("redisKey", redisKey);
  			response.addCookie(cookie);
  			// redis中存储
  			stringRedisTemplate.opsForValue().set(redisKey, username+password+"...", 30, TimeUnit.MINUTES);
  			// user中存储的url  重定向时候带着token
  			return "redirect:" + url + "?redisKey=" + redisKey;
  		}
  		// 登录失败
  		return "login";
  	}
  
  }
  ```

核心思想：

- server端第一次登陆认证成功 通过写入Cookie来实现下次是否认证判断，cookie存在即已登录。
- 重定向。

## 2.2 登出

参考：https://blog.csdn.net/tc979907461/article/details/107038122/?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242

- 服务端登出

  清空服务端用户信息，遍历所以在服务端登陆过得子系统，调用他们的登出url（服务端维护子系统的登陆，登出url，sessionId（存在数据库或redis等））

- 客户端登出

  用户执行登出操作，当前应用服务器会把这个登出请求重定向到CAS server，CAS server接受登出请求后，会检测用户的TCG Cookie，把对应的session清除，同时会找到所有通过该TGC sso登录的应用服务器URL提交请求,所有的回调请求中，包含一个参数logoutRequest,访问这个登出URL，
  所有收到请求的应用服务器(就是是CAS client)会解析这个参数，取得sessionId，根据这个Id取得session后，把session删除。这样就实现单点登出的功能，用户无法在这个具体应用上继续操作了，只能重新登录才行。

# 3 社交登陆OAuth2.0

**OAuth2.0：**对于用户相关的 OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保存用户数据的安全和隐私，第三方网站访问用户数据前都需要显示向用户授权

流程：

![image-20201110154532752](D:\study\github\StudyNote\开发\开发体系\解决方案\img\image-20201110154532752.png)