# 手机短信验证码防刷校验

用户要是一直提交刷新验证码

- 前台：限制一分钟后提交

- 后台：存入redis 如果有就返回

  ```java
  /**
   * 发送短信验证码
   * @param phone 手机号
   * @return
   */
  @GetMapping("/sms/sendCode")
  @ResponseBody
  public R sendCode(@RequestParam("phone") String phone) {
      // TODO 1、接口防刷
      // 先从redis中拿取
      String redisCode = redisTemplate.opsForValue().get(AuthServerConstant.SMS_CODE_CACHE_PREFIX + phone);
      if(!StringUtils.isEmpty(redisCode)) {
          // 拆分
          long l = Long.parseLong(redisCode.split("_")[1]);
          // 当前系统事件减去之前验证码存入的事件 小于60000毫秒=60秒
          if (System.currentTimeMillis() -l < 60000) {
              // 60秒内不能再发
              R.error(BizCodeEnume.SMS_CODE_EXCEPTION.getCode(),BizCodeEnume.SMS_CODE_EXCEPTION.getMsg());
          }
      }
      // 2、验证码的再次效验
      // 数据存入 =》redis key-phone value - code sms:code:131xxxxx - >45678
      String code = UUID.randomUUID().toString().substring(0,5).toUpperCase();
      // 拼接验证码
      String substring = code+"_" + System.currentTimeMillis();
      // redis缓存验证码 防止同一个phone在60秒内发出多次验证吗
      redisTemplate.opsForValue().set(AuthServerConstant.SMS_CODE_CACHE_PREFIX+phone,substring,10, TimeUnit.MINUTES);
  
      // 调用第三方服务发送验证码
      thirdPartFeignService.sendCode(phone,code);
      return R.ok();
  }
  ```

  ```java
  // 分布式锁  设置60s过期。前端的倒计时可以获取锁的过期时间
  ```

  

