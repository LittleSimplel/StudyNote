# 1 任务调度

## 1.1什么时候需要任务调度？

- 基于准确的时刻或者固定的时间间隔触发的任务
- 有批量数 据需要处理。
- 要实现两个动作解耦的场景

场景：账单日或者还款日上午 10 点，给每个信用卡客户发送账单通知，还款通知。如 何判断客户的账单日、还款日，完成通知的发送

## 1.2 任务调度需求分析

### 1.2.1 基本需求

- 可以定义触发的规则，比如基于时刻、时间间隔、表达式。

- 可以定义需要执行的任务。比如执行一个脚本或者一段代码。任务和规则是 分开的。 

- 集中管理配置，持久配置。不用把规则写在代码里面，可以看到所有的任务 配置，方便维护。重启之后任务可以再次调度——配置文件或者配置中心。 

- 支持任务的串行执行，例如执行 A 任务后再执行 B 任务再执行 C 任务。 

- 支持多个任务并发执行，互不干扰（例如 ScheduledThreadPoolExecutor）。

- 有自己的调度器，可以启动、中断、停止任务。 

- 容易集成到 Spring。

- 支持集群

## 1.3 任务调度工具对比

| 层次       | 举例                           | 特点                                                         |
| ---------- | ------------------------------ | ------------------------------------------------------------ |
| 操作系统   | Linux crontab Windows 计划任务 | 只能执行简单脚本或者命令                                     |
| 数据库     | MySQL、Oracle                  | 可以操作数据。不能执行 Java 代码                             |
| 工具       | Kettle                         | 可以操作数据，执行脚本。没有集中配置                         |
| 开发语言   | JDK Timer、ScheduledThreadPool | Timer：单线程 JDK1.5 之后：<br />ScheduledThreadPool（Cache、Fiexed、 Single）:没有集中配置，日程管理不够灵活 |
| 容器       | Spring Task、@Scheduled        | 不支持集群                                                   |
| 分布式框架 | XXL-JOB，Elastic-Job           |                                                              |

# 2 Quartz 

## 2.1Quartz 基本介绍

官网：http://www.quartz-scheduler.org.

Quartz 的意思是石英，像石英表一样精确。

Quatz 是一个特性丰富的，开源的任务调度库，它几乎可以嵌入所有的 Java 程序，从很小的独立应用程序到大型 商业系统。Quartz 可以用来创建成百上千的简单的或者复杂的任务，这些任务可以用来执行任何程序可以做的事情。 Quartz 拥有很多企业级的特性，包括支持 JTA 事务和集群。

特点:

- 精确到毫秒级别的调度 
- 可以独立运行，也可以集成到容器中 
- 支持事务（JobStoreCMT ）
-  支持集群 
- 支持持久化

## 2.2 Quartz Java 编程

### 2.2.1 引入依赖

```java
<dependency>
	<groupId>org.quartz-scheduler</groupId>
	<artifactId>quartz</artifactId>
	<version>2.3.0</version>
</dependency>
```

### 2.2.2 默认配置文件

org.quartz.core 包下，有一个默认的配置文件，quartz.properties。当我们没有 定义一个同名的配置文件的时候，就会使用默认配置文件里面的配置。

```java
org.quartz.scheduler.instanceName: DefaultQuartzScheduler
org.quartz.scheduler.rmi.export: false
org.quartz.scheduler.rmi.proxy: false
org.quartz.scheduler.wrapJobExecutionInUserTransaction: false
org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount: 10
org.quartz.threadPool.threadPriority: 5
org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true
org.quartz.jobStore.misfireThreshold: 60000
org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore
```

### 2.2.3 创建 Job

实现唯一的方法 execute()，方法中的代码就是任务执行的内容。此处仅输出字符串。

```java
public class MyJob implements Job {
	public void execute(JobExecutionContext context) throws JobExecutionException {
		//任务代码
	}
}
```

在测试类 main()方法中，把 Job 进一步包装成 JobDetail。 必须要指定 JobName 和 groupName，两个合起来是唯一标识符。 可以携带 KV 的数据（JobDataMap），用于扩展属性，在运行的时候可以从 context 获取到。

```java
JobDetail jobDetail = JobBuilder.newJob(MyJob1.class)
.withIdentity("job1", "group1")
.usingJobData("gupao","2673")
.usingJobData("moon",5.21F)
.build();
```

### 2.2.4 创建 Trigger

在测试类 main()方法中，基于 SimpleTrigger 定义了一个每 2 秒钟运行一次、不断重复的 Trigger

```java
Trigger trigger = TriggerBuilder.newTrigger()
	.withIdentity("trigger1", "group1")
	.startNow()
	.withSchedule(SimpleScheduleBuilder.simpleSchedule()
	.withIntervalInSeconds(2)
	.repeatForever())
	.build()
```

创建 Schedule:在测试类 main()方法中，通过 Factory 获取调度器的实例，把 JobDetail 和 Trigger 绑定，注册到容器中。 Scheduler 先启动后启动无所谓，只要有 Trigger 到达触发条件，就会执行任务。

```java
 SchedulerFactory factory = new StdSchedulerFactory();
 Scheduler scheduler = factory.getScheduler();
 scheduler.scheduleJob(jobDetail, trigger);
 scheduler.start()
```

注意这里，调度器一定是单例的。

## 2.3 Quartz 体系结构总结

<img src="D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907192419844.png" alt="image-20210907192419844" style="zoom:67%;" />

### 2.3.1 JobDetail

我们创建一个实现 Job 接口的类，使用 JobBuilder 包装成 JobDetail，它可以携带 KV 的数据。

### 2.3.2 Trigger

定义任务的触发规律，Trigger，使用 TriggerBuilder 来构建。 JobDetail 跟 Trigger 是 1:N 的关系。

Trigger 接口在 Quartz 有 4 个继承的子接口：

| 子接口                   | 描述                   | 特点                                                         |
| ------------------------ | ---------------------- | ------------------------------------------------------------ |
| SimpleTrigger            | 简单触发器             | 固定时刻或时间间隔，毫秒                                     |
| CalendarIntervalTrigger  | 基于日历的触发器       | 比简单触发器更多时间单位，支持非固定时 间的触发，<br />例如一年可能 365/366，一个月 可能 28/29/30/31 |
| DailyTimeIntervalTrigger | 基于日期的触发器       | 每天的某个时间段                                             |
| CronTrigger              | 基于 Cron 表达式的触发 |                                                              |

- SimpleTrigger：SimpleTrigger 可以定义固定时刻或者固定时间间隔的调度规则（精确到毫秒）。 例如：每天 9 点钟运行；每隔 30 分钟运行一次。
- CalendarIntervalTrigger：CalendarIntervalTrigger 可以定义更多时间单位的调度需求，精确到秒。 好处是不需要去计算时间间隔，比如 1 个小时等于多少毫秒。 例如每年、每个月、每周、每天、每小时、每分钟、每秒。 每年的月数和每个月的天数不是固定的，这种情况也适用。
- DailyTimeIntervalTrigger：每天的某个时间段内，以一定的时间间隔执行任务。 例如：每天早上 9 点到晚上 9 点，每隔半个小时执行一次，并且只在周一到周六执行。
- CronTrigger：CronTirgger 可以定义基于 Cron 表达式的调度规则，是最常用的触发器类型。

上面我们定义的都是在什么时间执行，但是我们有一些在什么时间不执行的需求， 比如：理财周末和法定假日购买不计息；证券公司周末和法定假日休市。 是不是要把日期写在数据库中，然后读取基于当前时间判断呢？

**基于 Calendar 的排除规则**

如果要在触发器的基础上，排除一些时间区间不执行任务，就要用到 Quartz 的 Calendar 类（注意不是 JDK 的 Calendar）。可以按年、月、周、日、特定日期、Cron 表达式排除。

<img src="D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907193834486.png" alt="image-20210907193834486" style="zoom: 50%;" />

使用：调用 Trigger 的 modifiedByCalendar()添加到触发器中，并且调用调度器的 addCalendar()方法注册排除规则。

| Calendar 名称   | 用法                                                         |
| --------------- | ------------------------------------------------------------ |
| BaseCalendar    | 为高级的 Calendar 实现了基本的功能，实现了 org.quartz.Calendar 接口 |
| AnnualCalendar  | 排除年中一天或多天                                           |
| CronCalendar    | 日历的这种实现排除了由给定的 CronExpression 表达的时间集合。 例如， 您可以使用此日历使用表达式“* * 0-7,18-23？* *”每天排除所有营业时 间（上午 8 点至下午 5 点）。 如果 CronTrigger 具有给定的 cron 表达式并 且与具有相同表达式的 CronCalendar 相关联，则日历将排除触发器包含的 所有时间，并且它们将彼此抵消。 |
| DailyCalendar   | 您可以使用此日历来排除营业时间（上午 8 点 - 5 点）每天。 每个 DailyCalendar 仅允许指定单个时间范围，并且该时间范围可能不会跨越每 日边界（即，您不能指定从上午 8 点至凌晨 5 点的时间范围）。 如果属 性 invertTimeRange 为 false（默认），则时间范围定义触发器不允许触发 的时间范围。 如果 invertTimeRange 为 true，则时间范围被反转 - 也就是 排除在定义的时间范围之外的所有时间。 |
| HolidayCalendar | 特别的用于从 Trigger 中排除节假日                            |
| MonthlyCalendar | 排除月份中的指定数天，例如，可用于排除每月的最后一天         |
| WeeklyCalendar  | 排除星期中的任意周几，例如，可用于排除周末，默认周六和周日   |

### 2.3.3 Scheduler

调度器，是 Quartz 的指挥官，由 StdSchedulerFactory 产生。它是单例的。 并且是 Quartz 中最重要的 API，默认是实现类是 StdScheduler，里面包含了一个 QuartzScheduler。QuartzScheduler 里面又包含了一个 QuartzSchedulerThread。

![image-20210907194951261](D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907194951261.png)

Scheduler 中的方法主要分为三大类：

1. 操作调度器本身，例如调度器的启动 start()、调度器的关闭 shutdown()。
2. 操作 Trigger，例如 pauseTriggers()、resumeTrigger()。
3. 操作 Job，例如 scheduleJob()、unscheduleJob()、rescheduleJob()

这些方法非常重要，可以实现任务的动态调度。

### 2.3.4 Listener

我们有这么一种需求，在每个任务运行结束之后发送通知给运维管理员。那是不是 要在每个任务的最后添加一行代码呢？这种方式对原来的代码造成了入侵，不利于维护。 如果代码不是写在任务代码的最后一行，怎么知道任务执行完了呢？或者说，怎么监测 到任务的生命周期呢？ 观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则 所有依赖它的对象都会得到通知并自动更新。 **Quartz 中提供了三种 Listener，监听 Scheduler 的，监听 Trigger 的，监听 Job 的**。 只需要创建类实现相应的接口，并在 Scheduler 上注册 Listener，便可实现对核心对象的监听。

#### 2.3.4.1 JobListener

四个方法：

| 方法                 | 作用或执行实际                                               |
| -------------------- | ------------------------------------------------------------ |
| getName()            | 返回 JobListener 的名称                                      |
| jobToBeExecuted()    | Scheduler 在 JobDetail 将要被执行时调用这个方法              |
| jobExecutionVetoed() | Scheduler 在 JobDetail 即将被执行，但又被 TriggerListener 否决了时调用这个方法 |
| jobWasExecuted()     | Scheduler 在 JobDetail 被执行之后调用这个方法                |

工具类：ListenerManager，用于添加、获取、移除监听器 工具类：Matcher，主要是基于 groupName 和 keyName 进行匹配。

<img src="D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907195856476.png" alt="image-20210907195856476" style="zoom:67%;" />

#### 2.3.4.2 TriggerListener

| 方法               | 作用或执行实际                                               |
| ------------------ | ------------------------------------------------------------ |
| getName()          | 返回监听器的名称                                             |
| triggerFired()     | Trigger 被触发，Job 上的 execute() 方法将要被执行时，Scheduler 就调用这个 方法 |
| vetoJobExecution() | 在 Trigger 触 发 后 ， Job 将 要 被 执 行 时 由 Scheduler 调 用 这 个 方 法 。 TriggerListener 给了一个选择去否决 Job 的执行。假如这个方法返回 true，这 个 Job 将不会为此次 Trigger 触发而得到执行 |
| triggerMisfired()  | Trigger 错过触发时调用                                       |
| triggerComplete()  | Trigger 被触发并且完成了 Job 的执行时，Scheduler调用这个方法 |

#### 2.3.4.3 SchedulerListener

// todo

## 2.4 JobStore

问题：最多可以运行多少个任务（磁盘、内存、线程数） 
Jobstore 用来存储任务和触发器相关的信息，例如所有任务的名称、数量、状态等 等。
Quartz 中有两种存储任务的方式，一种在在内存，一种是在数据库。

### 2.4.1 RAMJobStore

Quartz 默认的 JobStore 是 RAMJobstore，也就是把任务和触发器信息运行的信息 存储在内存中，用到了 HashMap、TreeSet、HashSet 等等数据结构。 如果程序崩溃或重启，所有存储在内存中的数据都会丢失。所以我们需要把这些数据持久化到磁盘。

### 2.4.2 JDBCJobStore

JDBCJobStore 可以通过 JDBC 接口，将任务运行数据保存在数据库中。

JDBC 的实现方式有两种，JobStoreSupport 类的两个子类： 

- JobStoreTX：在独立的程序中使用，自己管理事务，不参与外部事务。
-  JobStoreCMT：(Container Managed Transactions (CMT)，如果需要容器管理事 务时，使用它。 

使用 JDBCJobSotre 时，需要配置数据库信息：

```java
org.quartz.jobStore.class:org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass:org.quartz.impl.jdbcjobstore.StdJDBCDelegate
# 使用 quartz.properties，不使用默认配置
org.quartz.jobStore.useProperties:true
#数据库中 quartz 表的表名前缀
org.quartz.jobStore.tablePrefix:QRTZ_
org.quartz.jobStore.dataSource:myDS
#配置数据源
org.quartz.dataSource.myDS.driver:com.mysql.jdbc.Driver
org.quartz.dataSource.myDS.URL:jdbc:mysql://localhost:3306/gupao?useUnicode=true&characterEncoding=utf8
org.quartz.dataSource.myDS.user:root
org.quartz.dataSource.myDS.password:123456
org.quartz.dataSource.myDS.validationQuery=select 
```

`问题来了？需要建什么表？表里面有什么字段？字段类型和长度是什么？ 在官网的 Downloads 链接中，提供了 11 张表的建表语句： quartz-2.2.3-distribution\quartz-2.2.3\docs\dbTables 2.3 的版本在这个路径下：src\org\quartz\impl\jdbcjobstore`

**表名与作用：**

<img src="D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907201123858.png" alt="image-20210907201123858" style="zoom:80%;" />

# 3 Quartz动态调度的实现

springboot-quartz 工程

传统的 Spring 方式集成，由于任务信息全部配置在 xml 文件中，如果需要操作任务 或者修改任务运行频率，只能重新编译、打包、部署、重启，如果有紧急问题需要处理， 会浪费很多的时间。 有没有可以动态调度任务的方法？比如停止一个 Job？启动一个 Job？修改 Job 的 触发频率？ 读取配置文件、写入配置文件、重启 Scheduler 或重启应用明显是不可取的。 对于这种频繁变更并且需要实时生效的配置信息，我们可以放到哪里？ ZK、Redis、DB tables。 并且，我们可以提供一个界面，实现对数据表的轻松操作。

## 3.1 配置管理

这里我们用最简单的数据库的实现。

建一张什么样的表？参考 JobDetail 的属性。

```sql
CREATE TABLE `sys_job` (
`id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID', 
`job_name` varchar(512) NOT NULL COMMENT '任务名称', 
`job_group` varchar(512) NOT NULL COMMENT '任务组名', 
`job_cron` varchar(512) NOT NULL COMMENT '时间表达式', 
`job_class_path` varchar(1024) NOT NULL COMMENT '类路径,全类型', 
`job_data_map` varchar(1024) DEFAULT NULL COMMENT '传递 map 参数', 
`job_status` int(2) NOT NULL COMMENT '状态:1 启用 0 停用', 
`job_describe` varchar(1024) DEFAULT NULL COMMENT '任务功能描述', PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=utf8;
```

## 3.2 数据操作与任务调度

操作数据表非常简单，SSM 增删改查。 但是在修改了表的数据之后，怎么让调度器知道呢？ 

调度器的接口：`Scheduler`

在我们的需求中，我们需要做的事情： 

- 新增一个任务 
- 删除一个任务 
- 启动、停止一个任务
- 修改任务的信息（包括调度规律)

把相关的操作封装到一个工具 中 `SchedulerUtil`

## 3.3 两个问题要解决

### 3.3.1 容器启动(重启)

因为任务没有定义在 ApplicationContext.xml 中，而是放到了数据库中，Spring Boot 启动时，怎么读取任务信息？或者，怎么在 Spring 启动完成的时候做一些事情？ 

创建一个类，实现 CommandLineRunner 接口，实现 run 方法。 从表中查出状态是 1 的任务，然后构建

### 3.3.2 Service 类注入到 Job 中

Spring Bean 如何注入到实现了 Job 接口的类中？

原因： 因为定时任务 Job 对象的实例化过程是在 Quartz 中进行的，而 Service Bean 是由 Spring 容器管理的，Quartz 察觉不到 Service Bean 的存在，所以无法将 Service Bean 装配到 Job 对象中。

分析： Quartz 集成到 Spring 中，用到 SchedulerFactoryBean，其实现了 InitializingBean 方法，在唯一的方法 afterPropertiesSet()在 Bean 的属性初始化后调用

分析： Quartz 集成到 Spring 中，用到 SchedulerFactoryBean，其实现了 InitializingBean 方法，在唯一的方法 afterPropertiesSet()在 Bean 的属性初始化后调用。调度器用 AdaptableJobFactory 对 Job 对象进行实例化。所以，如果我们可以把这 个 JobFactory 指定为我们自定义的工厂的话，就可以在 Job 实例化完成之后，把 Job 纳入到 Spring 容器中管理。

解决这个问题的步骤：

1. 定义一个 AdaptableJobFactory，实现 JobFactory 接口，实现接口定义的 newJob 方法，在这里面返回 Job 实例。

2. 定义一个 MyJobFactory，继承 AdaptableJobFactory。使用 Spring 的 AutowireCapableBeanFactory，把 Job 实例注入到容器中。

   ```java
   @Component
   public class MyJobFactory extends AdaptableJobFactory {
   	@Autowired
   	private AutowireCapableBeanFactory capableBeanFactory;
       
   	protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {
   		Object jobInstance = super.createJobInstance(bundle);
   		capableBeanFactory.autowireBean(jobInstance);
   		return jobInstance;
   	}
   }
   ```

3. 指定 Scheduler 的 JobFactory 为自定义的 MyJobFactory。 `scheduler.setJobFactory(myJobFactory);`

# 4. Quarzt集群

## 4.1 为什么需要集群？

- 可用性：防止单点故障，减少对业务的影响 
- 负载：减少节点的压力，例如在 10 点要触发 1000 个任务，如果有 10 个节点，则每个 节点之需要执行 100 个任务

## 4.2 集群需要解决的问题？

1. 任务重跑，因为节点部署的内容是一样的，到 10 点的时候，每个节点都会执行 相同的操作，引起数据混乱。比如跑批，绝对不能执行多次。
2. 任务漏跑，假如任务是平均分配的，本来应该在某个节点上执行的任务，因为节点故障，一直没有得到执行。
3. 水平集群需要注意时间同步问题。
4. Quartz 使用的是随机的负载均衡算法，不能指定节点执行。

所以必须要有一种共享数据或者通信的机制。在分布式系统的不同节点中，我们可 以采用什么样的方式，实现数据共享？ 两两通信，或者基于分布式的服务，实现数据共享。

例如：ZK、Redis、DB。

同样的问题：建什么表？哪些字段？依旧使用系统自带的 11 张表。

## 4.3  集群配置与验证

quartz.properties 配置。

四个配置：集群实例 ID、集群开关、数据库持久化、数据源信息

注意先清空 quartz 所有表、改端口、两个任务频率改成一样

- 验证 1：先后启动 2 个节点，任务是否重跑
- 验证 2：停掉一个节点，任务是否漏跑

## 4.4 Quartz 调度原理

### 4.4.1 源码

getScheduler 方法创建线程池 ThreadPool，创建调度器 QuartzScheduler，创建 调度线程 QuartzSchedulerThread，调度线程初始处于暂停状态。 scheduleJob 将任务添加到 JobStore 中。 scheduler.start()方法激活调度器，QuartzSchedulerThread 从 timeTrriger 取出待 触 发 的 任 务 ， 并 包 装 成 TriggerFiredBundle ， 然 后 由 JobRunShellFactory 创 建 TriggerFiredBundle 的 执 行 线 程 JobRunShell ， 调 度 执 行 通 过 线 程 池 SimpleThreadPool 去执行 JobRunShell，而 JobRunShell 执行的就是任务类的 execute 方法：job.execute(JobExecutionContext context)。

### 4.4.2集群原理

基于数据库，如何实现任务的不重跑不漏跑？

问题 1：如果任务执行中的资源是“下一个即将触发的任务”，怎么基于数据库实现 这个资源的竞争？ 

问题 2：怎么对数据的行加锁？

<img src="D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907213531885.png" alt="image-20210907213531885" style="zoom:67%;" />

QRTZ_LOCKS 表，它会为每个调度器创建两行数据，获取 Trigger 和触发 Trigger 是两把锁

![image-20210907214007454](D:\study\github\StudyNote\开发\开发体系\任务调度\img\image-20210907214007454.png)

执行的 SQL 语句:

```sql
select * from QRTZ_LOCKS t where t.lock_name='TRIGGER_ACCESS' for update
```

注意：如果batchTriggerAcquisitionMaxCount设置的数量为 1（默认值），并且使用 JDBC JobStore（RAMJobStore 不支持 分 布 式 ， 只 有 一 个 调 度 器 实 例 ， 所 以 不 加 锁 ） ， 则 属 性 org.quartz.jobStore.acquireTriggersWithinLock 应设置为 true。否则不加锁可能会导 致任务重复执行。

```java
org.quartz.scheduler.batchTriggerAcquisitionMaxCount=1
org.quartz.jobStore.acquireTriggersWithinLock=true
```

# 问题

1、    一个任务10秒钟触发一次，但是每次执行需要60秒，在第20秒的时候，会同时运行两个任务吗？怎么禁止一个任务并发运行？

- 可配置

2、    现在有三个任务，任务A、任务B、任务C，怎么让多个任务串行执行，例如A执行完了之后再执行B，B执行完了再执行C？

- 设置成一个任务

3、    除了执行本地的代码之外，怎么调用其他系统的任务？

- http，rpc

4、任务在什么时候会错过触发？错过触发怎么办？

错过触发的原因：

- 禁止并发，已经到了下一次触发的时间
- 线程池数量不够
- trigger被pause
- 系统重启

错过触发后方案：

- 立即执行-
- 在下一次触发执行
- 不执行