### 互联网核心技术实践

#### 1.高可用

1. 什么是高可用：

2. 为什么要高可用：

3. 微服务高可用设计手段

![image-20210411114618262](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411114618262.png)

4. 服务实时监控
   - 请求平均耗时
   - 请求异常条数

5. 服务分级（具体根据公司业务分）

   ![image-20210411121349881](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411121349881.png)

6. 如何无缝**停止线上服务**

   - **网关层已具备热切换能力**（配置中心开关）
     - 案例：发公告：晚上22：00停止访问
       1. 通过配置中心参数，在网关层设置开关，22：00后屏蔽所有请求。
       2. 保证22：00之前的**请求处理完毕**再停止线上服务
          - 通过查看业务打印日志，不打印了，说明**请求处理完毕**
          - 前端访问超时时间（5s），在22：05即可关闭服务（实际可以多等些时间关闭服务）。22：00之前的请求，在22：05时，要么成功要么超时（失败）。
   - 网关层不具备热切换能力
     - 防火墙设置只出不进

#### 2.无状态化设计

1. 概念
   - 同一服务（进程），冗余部署N份，N份完全对等。
   - 请求提交到任何一份冗余服务上，处理结果完全一样。

2. 目的
   - 快速扩容服务
   - 弹性缩容服务

3. 案列：用户session数据

   - 登录方式
     - 账号+密码
     - 账号+验证码
   - 登录成功
     - 生成用户凭证（session）
     - AES（UID+Timestmap+校验码）

   **用户session存放方式：**

   1. 用户session数据直接存储网关层（网关层有状态）
   2. 用户session数据存储客户端
      - 网关层无状态化
      - 存在问题：Session丢失；数据发送耗时。
      - 实现方式：JWT
   3. 用户Session数据外部存储
      - 网关层无状态化
      - session数据高可用
      - 实现方式：session数据存在redis集群（dodis），主从结构，分片存储（uid%分片数）

#### 3.负载均衡设计

1. 负载均衡系统和算法

   ![image-20210411143807146](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411143807146.png)

2. 完整的故障处理恢复机制
   - 故障自我发现（心跳，自定义的故障判断算法）
   - 故障服务自动摘除
     - 服务熔断机制
   - 请求自动重试（请求未故障的服务）
   - 服务恢复自动发现

#### 4.幂等设计

1. 请求幂等（请求转账）：保证请求重复执行和执行一次结果相同

   - 读请求（不需要幂等）
   - 写请求（insert,update,delete）

   本质：对数据发生改变的操作

   ① 单表幂等：在**数据访问层**实现幂等

   - Create/Insert
     - 业务主键  天然幂等
     - 自增主键/uuid（存在幂等问题）（一般不用自增主键）

   - update

     - update user set age=18 where uid=11；天然幂等
     - update user set age++ where uid=11；   不幂等（加乐观锁实现幂等，加version字段或用age字段本身。update user set age++ where uid=11 and age = 18）

   - Delete

     - delete user where uid = 11；天然幂等
     - delete user where uid in bottom 10；不幂等（一般不会这么写delete）

     修改，删除将相对修改改为绝对修改

   **② 多表需要用分布式事务处理**

   ③ **分层服务冗余部署，下单问题**（orderid主键，出现问题时**重试**下单，会重复插入）

   - app客户端生成orderid，加验证解决安全问题
   - 只在数据访问层重试
   - 生成的orderid，存入redis，重试的时候进行判断
   - 根据业务规则（has（uid，price...））,生成唯一的orderid

2. 业务幂等（用户下单）

   分布式锁

#### 5.分布式锁设计

1. 业务场景

   - 交易商品库锁定，防止用户重复下单。
   - mq消息去重，防止消息重复消费，消费端去重。
   - 订单操作变更协同：在用户对商品下单后，订单状态为待支付，在某一时刻用户正在对该订单做支付操作，商家对该订单进行改价操作。状态的修改行为需要做串行处理，避免出现数据不一致性。

   **本质：对共享数据的修改**

   保证数据的一致性：锁

   -  本地锁
   - 分布式部署：分布式锁

2. 基于Redis的分布式锁方案
   - 原理：redis单线程处理
   - 实现方式：setnx（）
   - 存在问题（浅层次）
     - 单机 （宕机）
     - 主从（在主数据未同步到从时，主宕机了，从变成主时，无法保证数据强一致性）
     - 锁时间不可控：无法续租期。
   - 存在问题（深层次）
     - 本质：分布式锁是cp模型，Redis集群是AP模型。
     - 业务场景区分：对数据一致性要求高的场景不适合用redis做分布式锁。

3. 存储模型的选择

   - Cp模型

   - zookeeper对锁的现实使用创建临时节点和watch机制，并发执行效率，扩展能力，社区活跃的等方面低于etcd

   - 选择基于etcd实现

     |            | redis  | zookeeper       | etcd        |
     | ---------- | ------ | --------------- | ----------- |
     | 一致性算法 | 无     | paxos           | raft        |
     | CAP        | AP     | CP              | CP          |
     | 高可用     | 主从   | N+1可用         | N+1可用     |
     | 接口类型   | 客户端 | 客户端          | http/grpc   |
     | 实现       | setnx  | createEphemeral | restful API |

4. 实现目标

5. 基于etcd实现分布式锁

   客户端：jar；服务端：集群（N+1）

   - CLient TTL 模式
     - ClientA->etcd->("key","ttl","value","uuid")     // value cas值， uuid不需要写
     - ClientB->etcd->("key","ttl","value","uuid")
     - ClientA拿锁成功，ClientB拿锁失败
     - A服务需要对 etcd保持后台心跳线程
       - 比如key的租期为10ms，后台心态线程3ms，心跳线程负责在拿到key之后，每3ms CAS唯一凭证uuid。

   - 申请锁

     - 业务方申请资源锁，调用时提供key，ttl

     - etcd生成uuid，作为当前锁的唯一凭证，将（key，uuid，ttl）写etcd

     - 检查etcd中此key是否存在，如没有，尝试写入key，写入失败，拿锁失败，写入成功拿到锁。

     - 拿锁后，心跳线程启动，心跳线程维持时间为ttl/3.CAS uuid，从而将key值续租。

     - 相关etcd API

       1. 申请锁：curl http://127.0.0.1:2379/v2/keys/199 -XPUT -d value=com -d ttl=5 prevExist=false
       2. CAS更新锁租约：curl  http://127.0.0.1:2379/v2/keys/199?preValue=com -XPUT -d ttl=5 -d refresh=true -d preExist
       3. CAS删除锁:curl http://127.0.0.1:2379/v2/keys/199?preValue=com -XDELETE

       199为key  com为value

   - 申请锁，但锁已被持有

     - 业务方申请资源锁，调用时提供key,ttl
     - 检查etcd中的key的存在，若已存在，拿锁失败

   - 锁的清理

     - 如果调用方正常结束，通过cas接口调用delete方法自动清理etcd中的key值。
     - 如果调用方异常终止，等待原有锁ttl过期后，锁资源释放。

   - 获取锁的平均耗时监控

     - 每天有千万级的锁操作，平均耗时1.34ms
     - 由于etcd强一致性，根据raft算法，消耗时间稍微长一点。

   - etcd测试

     ![image-20210413204828315](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210413204828315.png)

   - 特殊场景

     1. **分布式锁只是在同一自然时间的互斥锁，本身不解决幂等性问题。**
     2. 所没有按照预期续租
        - Gc时间大于租期时间：将租期时间设置长一点。
        - 租期时间只能设置很短：部署etcd集群。
     3. etcd内部协调发生问题。


#### 6.分布式事务

1. 导致数据不一致的原因

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112126725.png" alt="image-20210416112126725" style="zoom:67%;" />

2. 案列

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112215761.png" alt="image-20210416112215761" style="zoom:67%;" />

3. 分布式事务类型
   - 刚性分布式事务
     - 强一致性
     - XA模型
     - CPA理论-CP
   - 柔性分布式事务
     - 最终一致性
     - BASE，CPA理论-AP

4. 刚性分布式事务

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112812104.png" alt="image-20210416112812104" style="zoom:67%;" />

   **两阶段提交：**

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112907051.png" alt="image-20210416112907051" style="zoom:67%;" />

5. 柔性分布式事务

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113043995.png" alt="image-20210416113043995" style="zoom:67%;" />

   - **TCC模型**

     ![image-20210416113149666](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113149666.png)

   - **Saga模型**

     ![image-20210416113626875](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113626875.png)

   - 异步分布式场景设计

     ![image-20210416113912219](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113912219.png)

     - 方案一：业务方提供本地操作成功回查功能

       ![image-20210416114735796](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416114735796.png)

       <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416114909555.png" alt="image-20210416114909555" style="zoom: 80%;" />

     - 方案二：本地消息事务表

       <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416123446209.png" alt="image-20210416123446209" style="zoom:67%;" />

       ​			![image-20210416123530106](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416123530106.png)

   ​             		

### 7.服务降级

#### 定义

当整体服务负载超出预设的上限阈值或即将到来的流量预计会超过预设的阈值时，为了保证重要或基本的服务能正常运行，拒绝部分请求或者将一些不重要或不紧急的服务或任务进行服务的延迟使用或者暂停使用。

#### 目的

自我保护：流量高峰期，短时请求量大，服务能力有限，系统雪崩。->  服务降级。

#### 目标

保证核心服务可用，非核心服务弱可用。

#### 手段

- 拒绝部分请求（设定规则，自动降级）

- 关闭部分服务（边缘服务）

**拒绝部分请求方式**

1. 拒绝部分老请求 

   网关：

   - IO 线程，收包 将请求放到队列（req1，req2.....）

   - 工作线程 ，认证，分发路由

     1. 拒绝部分老请求：req出队时间-req入队时间>1s (时间规则)

     2. 区分核心业务：定长header（uid，cmd，sessionid，bodylength）cmd保存业务请求名，在配置中心配置核心业务。

   **开启或恢复**：通过队列（出队时间-req入队时间）请求的平均时间。

2. 优先级请求方式
   
- 非核心请求直接丢弃
  
3. 随机拒绝方式
   - 随机丢弃一定比列请求
   - 网站一会可用，一会不可用

#### 服务层降级架构层次

- 集中式

  网关层 （耦合）不推荐

- 自治式

  - 网关层
  - 业务逻辑层
  - 数据访问层
  - 数据层（不需要做降级）

服务降级可用策略

- 自动打开，不依赖人工。
- 演练（人工制造故障）

### 8. 服务熔断

#### 目的

![image-20210501125731650](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501125731650.png)

#### 业界方案

**Netflix OSS Hystrix**

- 手动写Hystrix command，或者是由maven插件生成command，在fall back method 里面返回NULL。
  - 业务浸入大，每个方法都要加注解
- 加入jar包
  - 客户端直接引用，重启代价

**平台化管理**

- RPC Client + 服务治理平台
- 基于PRC Client实现熔断
- PRC Client 修改创建的proxy（动态代理），在proxy内部由本地**计算统计**决定是否熔断
- 服务治理平台存储降级相关的配置，以及提供上报数据的可视化，报警，配置变更下推等功能。

#### 熔断方案交互流程

![微信图片_20210501131837](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210501131837.jpg)

![image-20210501132656318](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501132656318.png)

### 9.灰度发布

#### 定义和目的

![image-20210501143823742](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501143823742.png)

#### 服务灰度发布

![image-20210501145431972](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501145431972.png)

![image-20210501145616347](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501145616347.png)

#### 灰度发布系统协议

![image-20210501145735359](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501145735359.png)

#### 灰度发布系统案例

![image-20210501145907453](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501145907453.png)

#### 灰度发布的复杂场景

- 多服务灰度发布

  ![image-20210501150036397](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501150036397.png)

- 数据灰度发布

  ![image-20210501150206019](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501150206019.png)

- 客户端灰度发布

  ![image-20210501150325905](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501150325905.png)

### 全链路压测

#### 定义和目的

![image-20210501154959601](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501154959601.png)

#### 压测工具和测试标准

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501155118110.png" alt="image-20210501155118110" style="zoom: 33%;" />

#### 压测实施方案和条件

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501155401620.png" alt="image-20210501155401620" style="zoom:33%;" />

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501155619639.png" alt="image-20210501155619639" style="zoom: 40%;" />

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501155728978.png" alt="image-20210501155728978" style="zoom:33%;" />

<img src="C:\Users\zyc\AppData\Roaming\Typora\typora-user-images\image-20210501155818311.png" alt="image-20210501155818311" style="zoom:30%;" />

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501155854964.png" alt="image-20210501155854964" style="zoom:33%;" />

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501155922771.png" alt="image-20210501155922771" style="zoom:34%;" />

### 11 高并发设计

#### 系统性能要素

- 吞吐量
- 平均响应延时

#### 性能优化手段

![image-20210501161048724](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501161048724.png)

**调用了多少RPC接口，载入多少数据，使用什么算法，非核心流程能否异步化；没用数据依赖的逻辑能够并行。**

![image-20210501161739574](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501161739574.png)

#### 代码优化

![image-20210501162758419](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501162758419.png)

- 扩大到一般场景,业务系统使用缓存降低响应时间提高性能,必须提高缓存命中率
- 很聚焦的高频访问,时效性要求不高很适合缓存提升性能,很聚焦的高频访问业务如banner, 广告位,时效性要
  求不是特别高,比如更新了可以不用实时体现,很适合使用缓存提升性能
- 如果对数据实时性要求很高,比如严格的时效性,需要慎重考虑更新缓存带来的一致性问题
- 时效性和缓存的冲突,比如商品服务对商品进行了缓存,由于更新缓存和更新商品不是同一个事事务,则对数据时
  效性要求高的如交易,就只能直接从数据库查商品信息

#### 算法优化

<img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501163121484.png" alt="image-20210501163121484" style="zoom:60%;" />

- 并发和锁的优化,读多写少的业务场景下,基于CAS的LockFreettmutex性能更好
- 当系统时间是瓶颈,采取空间换时间逻辑算法,分配更多空间节省系统时间
  - 缓存复用计算结果,,降低时间开销,CPU时间较内存容量更加昂贵
- 当系统空间容量是瓶颈,采取时间换空间算法策略
  - 网络传输是瓶颈,使用系统时间换取空间的压缩,HTTP的g2zip压缩算法
  -  APP的请求分类接口,使用版本号判断哪些数据更新,只下载更新的数据,使用更多的代码逻辑处理更细粒度的数据
- 并行执行,比如一段逻辑调用了多个RPC接口,而这些接口之间并没有数据依赖,则可以考虑并行调用,降低响应时间
- 异步执行,分析业务流程中的主次流程,把次要流程拆分出来异步执行,更进一一步可以拆分到单独的模块去执行,比如使用消息队列,彻底和核心流程解耦,提高核心流程的稳定性以及降低响应时间

#### sql优化

#### 架构优化

![image-20210501163234654](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501163234654.png)

#### 案例

**feed系统**

![image-20210501163328154](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501163328154.png)

**feed系统分级缓存**

![image-20210501163402434](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501163402434.png)

**feed系统消息发布**

![image-20210501163453645](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501163453645.png)

**feed系统数据存储选型**

![image-20210501163521649](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210501163521649.png)