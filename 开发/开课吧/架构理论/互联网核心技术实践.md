### 互联网核心技术实践

#### 高可用

1. 什么是高可用：

2. 为什么要高可用：

3. 微服务高可用设计手段

![image-20210411114618262](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411114618262.png)

4. 服务实时监控
   - 请求平均耗时
   - 请求异常条数

5. 服务分级（具体根据公司业务分）

   ![image-20210411121349881](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411121349881.png)

6. 如何无缝**停止线上服务**

   - **网关层已具备热切换能力**（配置中心开关）
     - 案例：发公告：晚上22：00停止访问
       1. 通过配置中心参数，在网关层设置开关，22：00后屏蔽所有请求。
       2. 保证22：00之前的**请求处理完毕**再停止线上服务
          - 通过查看业务打印日志，不打印了，说明**请求处理完毕**
          - 前端访问超时时间（5s），在22：05即可关闭服务（实际可以多等些时间关闭服务）。22：00之前的请求，在22：05时，要么成功要么超时（失败）。
   - 网关层不具备热切换能力
     - 防火墙设置只出不进

#### 无状态化设计

1. 概念
   - 同一服务（进程），冗余部署N份，N份完全对等。
   - 请求提交到任何一份冗余服务上，处理结果完全一样。

2. 目的
   - 快速扩容服务
   - 弹性缩容服务

3. 案列：用户session数据

   - 登录方式
     - 账号+密码
     - 账号+验证码
   - 登录成功
     - 生成用户凭证（session）
     - AES（UID+Timestmap+校验码）

   **用户session存放方式：**

   1. 用户session数据直接存储网关层（网关层有状态）
   2. 用户session数据存储客户端
      - 网关层无状态化
      - 存在问题：Session丢失；数据发送耗时。
      - 实现方式：JWT
   3. 用户Session数据外部存储
      - 网关层无状态化
      - session数据高可用
      - 实现方式：session数据存在redis集群（dodis），主从结构，分片存储（uid%分片数）

#### 负载均衡设计

1. 负载均衡系统和算法

   ![image-20210411143807146](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411143807146.png)

2. 完整的故障处理恢复机制
   - 故障自我发现（心跳，自定义的故障判断算法）
   - 故障服务自动摘除
     - 服务熔断机制
   - 请求自动重试（请求未故障的服务）
   - 服务恢复自动发现

#### 幂等设计

1. 请求幂等（请求转账）：保证请求重复执行和执行一次结果相同

   - 读请求（不需要幂等）
   - 写请求（insert,update,delete）

   本质：对数据发生改变的操作

   ① 单表幂等：在**数据访问层**实现幂等

   - Create/Insert
     - 业务主键  天然幂等
     - 自增主键/uuid（存在幂等问题）（一般不用自增主键）

   - update

     - update user set age=18 where uid=11；天然幂等
     - update user set age++ where uid=11；   不幂等（加乐观锁实现幂等，加version字段或用age字段本身。update user set age++ where uid=11 and age = 18）

   - Delete

     - delete user where uid = 11；天然幂等
     - delete user where uid in bottom 10；不幂等（一般不会这么写delete）

     修改，删除将相对修改改为绝对修改

   **② 多表需要用分布式事务处理**

   ③ **分层服务冗余部署，下单问题**（orderid主键，出现问题时**重试**下单，会重复插入）

   - app客户端生成orderid，加验证解决安全问题
   - 只在数据访问层重试
   - 生成的orderid，存入redis，重试的时候进行判断
   - 根据业务规则（has（uid，price...））,生成唯一的orderid

2. 业务幂等（用户下单）

   分布式锁

#### 分布式锁设计

1. 业务场景

   - 交易商品库锁定，防止用户重复下单。
   - mq消息去重，防止消息重复消费，消费端去重。
   - 订单操作变更协同：在用户对商品下单后，订单状态为待支付，在某一时刻用户正在对该订单做支付操作，商家对该订单进行改价操作。状态的修改行为需要做串行处理，避免出现数据不一致性。

   **本质：对共享数据的修改**

   保证数据的一致性：锁

   -  本地锁
   - 分布式部署：分布式锁

2. 基于Redis的分布式锁方案
   - 原理：redis单线程处理
   - 实现方式：setnx（）
   - 存在问题（浅层次）
     - 单机 （宕机）
     - 主从（在主数据未同步到从时，主宕机了，从变成主时，无法保证数据强一致性）
     - 锁时间不可控：无法续租期。
   - 存在问题（深层次）
     - 本质：分布式锁是cp模型，Redis集群是AP模型。
     - 业务场景区分：对数据一致性要求高的场景不适合用redis做分布式锁。

3. 存储模型的选择

   - Cp模型

   - zookeeper对锁的现实使用创建临时节点和watch机制，并发执行效率，扩展能力，社区活跃的等方面低于etcd

   - 选择基于etcd实现

     |            | redis  | zookeeper       | etcd        |
     | ---------- | ------ | --------------- | ----------- |
     | 一致性算法 | 无     | paxos           | raft        |
     | CAP        | AP     | CP              | CP          |
     | 高可用     | 主从   | N+1可用         | N+1可用     |
     | 接口类型   | 客户端 | 客户端          | http/grpc   |
     | 实现       | setnx  | createEphemeral | restful API |

4. 实现目标

5. 基于etcd实现分布式锁

   客户端：jar；服务端：集群（N+1）

   - CLient TTL 模式
   - 申请锁
   - 申请锁，但锁已被持有