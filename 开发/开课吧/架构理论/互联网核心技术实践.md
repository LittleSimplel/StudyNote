### 互联网核心技术实践

#### 高可用

1. 什么是高可用：

2. 为什么要高可用：

3. 微服务高可用设计手段

![image-20210411114618262](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411114618262.png)

4. 服务实时监控
   - 请求平均耗时
   - 请求异常条数

5. 服务分级（具体根据公司业务分）

   ![image-20210411121349881](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411121349881.png)

6. 如何无缝**停止线上服务**

   - **网关层已具备热切换能力**（配置中心开关）
     - 案例：发公告：晚上22：00停止访问
       1. 通过配置中心参数，在网关层设置开关，22：00后屏蔽所有请求。
       2. 保证22：00之前的**请求处理完毕**再停止线上服务
          - 通过查看业务打印日志，不打印了，说明**请求处理完毕**
          - 前端访问超时时间（5s），在22：05即可关闭服务（实际可以多等些时间关闭服务）。22：00之前的请求，在22：05时，要么成功要么超时（失败）。
   - 网关层不具备热切换能力
     - 防火墙设置只出不进

#### 无状态化设计

1. 概念
   - 同一服务（进程），冗余部署N份，N份完全对等。
   - 请求提交到任何一份冗余服务上，处理结果完全一样。

2. 目的
   - 快速扩容服务
   - 弹性缩容服务

3. 案列：用户session数据

   - 登录方式
     - 账号+密码
     - 账号+验证码
   - 登录成功
     - 生成用户凭证（session）
     - AES（UID+Timestmap+校验码）

   **用户session存放方式：**

   1. 用户session数据直接存储网关层（网关层有状态）
   2. 用户session数据存储客户端
      - 网关层无状态化
      - 存在问题：Session丢失；数据发送耗时。
      - 实现方式：JWT
   3. 用户Session数据外部存储
      - 网关层无状态化
      - session数据高可用
      - 实现方式：session数据存在redis集群（dodis），主从结构，分片存储（uid%分片数）

#### 负载均衡设计

1. 负载均衡系统和算法

   ![image-20210411143807146](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210411143807146.png)

2. 完整的故障处理恢复机制
   - 故障自我发现（心跳，自定义的故障判断算法）
   - 故障服务自动摘除
     - 服务熔断机制
   - 请求自动重试（请求未故障的服务）
   - 服务恢复自动发现

#### 幂等设计

1. 请求幂等（请求转账）：保证请求重复执行和执行一次结果相同

   - 读请求（不需要幂等）
   - 写请求（insert,update,delete）

   本质：对数据发生改变的操作

   ① 单表幂等：在**数据访问层**实现幂等

   - Create/Insert
     - 业务主键  天然幂等
     - 自增主键/uuid（存在幂等问题）（一般不用自增主键）

   - update

     - update user set age=18 where uid=11；天然幂等
     - update user set age++ where uid=11；   不幂等（加乐观锁实现幂等，加version字段或用age字段本身。update user set age++ where uid=11 and age = 18）

   - Delete

     - delete user where uid = 11；天然幂等
     - delete user where uid in bottom 10；不幂等（一般不会这么写delete）

     修改，删除将相对修改改为绝对修改

   **② 多表需要用分布式事务处理**

   ③ **分层服务冗余部署，下单问题**（orderid主键，出现问题时**重试**下单，会重复插入）

   - app客户端生成orderid，加验证解决安全问题
   - 只在数据访问层重试
   - 生成的orderid，存入redis，重试的时候进行判断
   - 根据业务规则（has（uid，price...））,生成唯一的orderid

2. 业务幂等（用户下单）

   分布式锁

#### 分布式锁设计

1. 业务场景

   - 交易商品库锁定，防止用户重复下单。
   - mq消息去重，防止消息重复消费，消费端去重。
   - 订单操作变更协同：在用户对商品下单后，订单状态为待支付，在某一时刻用户正在对该订单做支付操作，商家对该订单进行改价操作。状态的修改行为需要做串行处理，避免出现数据不一致性。

   **本质：对共享数据的修改**

   保证数据的一致性：锁

   -  本地锁
   - 分布式部署：分布式锁

2. 基于Redis的分布式锁方案
   - 原理：redis单线程处理
   - 实现方式：setnx（）
   - 存在问题（浅层次）
     - 单机 （宕机）
     - 主从（在主数据未同步到从时，主宕机了，从变成主时，无法保证数据强一致性）
     - 锁时间不可控：无法续租期。
   - 存在问题（深层次）
     - 本质：分布式锁是cp模型，Redis集群是AP模型。
     - 业务场景区分：对数据一致性要求高的场景不适合用redis做分布式锁。

3. 存储模型的选择

   - Cp模型

   - zookeeper对锁的现实使用创建临时节点和watch机制，并发执行效率，扩展能力，社区活跃的等方面低于etcd

   - 选择基于etcd实现

     |            | redis  | zookeeper       | etcd        |
     | ---------- | ------ | --------------- | ----------- |
     | 一致性算法 | 无     | paxos           | raft        |
     | CAP        | AP     | CP              | CP          |
     | 高可用     | 主从   | N+1可用         | N+1可用     |
     | 接口类型   | 客户端 | 客户端          | http/grpc   |
     | 实现       | setnx  | createEphemeral | restful API |

4. 实现目标

5. 基于etcd实现分布式锁

   客户端：jar；服务端：集群（N+1）

   - CLient TTL 模式
     - ClientA->etcd->("key","ttl","value","uuid")     // value cas值， uuid不需要写
     - ClientB->etcd->("key","ttl","value","uuid")
     - ClientA拿锁成功，ClientB拿锁失败
     - A服务需要对 etcd保持后台心跳线程
       - 比如key的租期为10ms，后台心态线程3ms，心跳线程负责在拿到key之后，每3ms CAS唯一凭证uuid。

   - 申请锁

     - 业务方申请资源锁，调用时提供key，ttl

     - etcd生成uuid，作为当前锁的唯一凭证，将（key，uuid，ttl）写etcd

     - 检查etcd中此key是否存在，如没有，尝试写入key，写入失败，拿锁失败，写入成功拿到锁。

     - 拿锁后，心跳线程启动，心跳线程维持时间为ttl/3.CAS uuid，从而将key值续租。

     - 相关etcd API

       1. 申请锁：curl http://127.0.0.1:2379/v2/keys/199 -XPUT -d value=com -d ttl=5 prevExist=false
       2. CAS更新锁租约：curl  http://127.0.0.1:2379/v2/keys/199?preValue=com -XPUT -d ttl=5 -d refresh=true -d preExist
       3. CAS删除锁:curl http://127.0.0.1:2379/v2/keys/199?preValue=com -XDELETE

       199为key  com为value

   - 申请锁，但锁已被持有

     - 业务方申请资源锁，调用时提供key,ttl
     - 检查etcd中的key的存在，若已存在，拿锁失败

   - 锁的清理

     - 如果调用方正常结束，通过cas接口调用delete方法自动清理etcd中的key值。
     - 如果调用方异常终止，等待原有锁ttl过期后，锁资源释放。

   - 获取锁的平均耗时监控

     - 每天有千万级的锁操作，平均耗时1.34ms
     - 由于etcd强一致性，根据raft算法，消耗时间稍微长一点。

   - etcd测试

     ![image-20210413204828315](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210413204828315.png)

   - 特殊场景

     1. **分布式锁只是在同一自然时间的互斥锁，本身不解决幂等性问题。**
     2. 所没有按照预期续租
        - Gc时间大于租期时间：将租期时间设置长一点。
        - 租期时间只能设置很短：部署etcd集群。
     3. etcd内部协调发生问题。


#### 分布式事务

1. 导致数据不一致的原因

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112126725.png" alt="image-20210416112126725" style="zoom:67%;" />

2. 案列

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112215761.png" alt="image-20210416112215761" style="zoom:67%;" />

3. 分布式事务类型
   - 刚性分布式事务
     - 强一致性
     - XA模型
     - CPA理论-CP
   - 柔性分布式事务
     - 最终一致性
     - BASE，CPA理论-AP

4. 刚性分布式事务

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112812104.png" alt="image-20210416112812104" style="zoom:67%;" />

   **两阶段提交：**

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416112907051.png" alt="image-20210416112907051" style="zoom:67%;" />

5. 柔性分布式事务

   <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113043995.png" alt="image-20210416113043995" style="zoom:67%;" />

   - **TCC模型**

     ![image-20210416113149666](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113149666.png)

   - **Saga模型**

     ![image-20210416113626875](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113626875.png)

   - 异步分布式场景设计

     ![image-20210416113912219](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416113912219.png)

     - 方案一：业务方提供本地操作成功回查功能

       ![image-20210416114735796](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416114735796.png)

       <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416114909555.png" alt="image-20210416114909555" style="zoom: 80%;" />

     - 方案二：本地消息事务表

       <img src="https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416123446209.png" alt="image-20210416123446209" style="zoom:67%;" />

       ​			![image-20210416123530106](https://study-java-img.oss-cn-guangzhou.aliyuncs.com/img/image-20210416123530106.png)

   ​             		

