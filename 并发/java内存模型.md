### Java虚拟机

#### 启动流程

​	在运行程序的时候启动，不是在运行main方法的时候，是在运行main方法之前。一个java程序一次只能运行一个main方法，在main方法执行之前会首先创建一个JVM实例，一个main对应一个jvm实例，各个JVM实例之间是相互隔离的。

![jvm启动流程.png](http://ww1.sinaimg.cn/large/0062TeRXgy1gd1l5bo1jyj30uh09mq4h.jpg)

#### 内存划分

![jvm内存区域.png](http://ww1.sinaimg.cn/large/0062TeRXgy1gd1oczumx6j30ih0d645f.jpg)

 1. **程序计数器**

    ​	程序计数器是一块很小的内存空间，它是**线程私有的**，可以认作为当前线程的行号指示器

    **为什么需要程序计数器**

    > 我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。这块内存区域是虚拟机规范中**唯一没有OutOfMemoryError的区域**

2. **虚拟机栈**

   ​	栈描述的是Java方法执行的内存模型。**每个方法被执行的时候都会创建一个栈帧**用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被。**线程私有的**，局部变量表所需要的内存空间在**编译期**完成分配。

   ![vm栈.png](http://ww1.sinaimg.cn/mw690/0062TeRXgy1gd1lipkaqzj30q70c00x9.jpg)



3. **本地方法栈**

   > 本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。**线程私有的**

4. **堆**

   ​	堆是java虚拟机管理内存最大的一块内存区域，**线程共享的**
   ​	**jvm 优化本质**： 减少 full gc 的频率和时间

5. **方法区**

   ​	方法区同堆一样，是所有**线程共享**的内存区域。用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。

   > 运行时常量池是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用

#### 类加载

1. 类的加载

   ​	JVM将class文件字节码文件加载到内存中， 并将这些静态数据转换成方法区中的运行时数据结构，在堆(并不一定在堆中，HotSpot在方法区中)中生成一个代表这个类的java.lang.Class 对象，作为方法区类数据的访问入口。

   不需要等到程序启动，预加载。s

2. 类的生命周期

   JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化

3. 类加载器

   通过一个类的全限定名来获取描述此类的二进制字节流

   可以自行实现类加载器来加载其他格式的类

   分为：启动类加载器；扩展类加载器；应用程序类加载器

4. 双亲委派机制

   ​	如果一个类加载器收到了类加载器的请求.它首先不会自己去尝试加载这个类.而是把这个请求委派给父加载器去完成.每个层次的类加载器都是如此.因此所有的加载请求最终都会传送到Bootstrap类加载器(启动类加载器)中.只有父类加载反馈自己无法加载这个请求(它的搜索范围中没有找到所需的类)时.子加载器才会尝试自己去加载。

   **作用：**

   1. 防止重复加载同一个`.class`
   2. 保证核心`.class`不能被篡改

### Java 内存模型

> Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。简要言之，jmm是jvm的一种规范，定义了jvm的内存模型。它屏蔽了各种硬件和操作系统的访问差异，不像c那样直接访问硬件内存，相对安全很多，它的主要目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。可以保证并发编程场景中的原子性、可见性和有序性。

![Java内存模型.png](http://ww1.sinaimg.cn/mw690/0062TeRXgy1gd1mrn3i3lj30qn0bjgoj.jpg)

1. 主内存：共享的信息（可理解为堆）

2. 工作内存：私有信息（可理解为栈）

3. 工作方式：

   - 线程修改私有数据，直接在工作内存修改

   - 线程修改共享数据，把数据复制到工作内存中去，在工作内存中修改，修改完成以后，刷新到主内存中

   **Java内存模型的作用：规范内存数据和工作内存数据的交互**

### 硬件内存架构

![硬件架构模型.png](http://ww1.sinaimg.cn/large/0062TeRXgy1gd1n7ziyboj30bl0dxta3.jpg)

- CPU缓存的一致性问题：并发处理的不同步

  解决方案：

  - 总线加锁（）  降低CPU的吞吐量

  - 缓存上的一致性协议（MESI）

    当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行新修改，并更新到主内存

    CacheLine置无效，其他的CPU重新从主内存中读数据

### 并发编程

#### 线程

#### 并发编程的三个重要特性

1. 原子性：不可分割

2. 可见性：线程只能操作自己工作空间中的数据

3. 有序性：程序中的顺序不一定就是执行的顺序，jvm通过编译重排序，指令重排序，提高效率 

   as-if-seria ，happens-before原则

#### JMM对三个特征的保证

1. **原子性**

   - x=10  写 

     如果是私有数据具有原子性，如果是共享数据没原子性（读写都是）  

   - y=x  没有原子性

     把数据 x 读到工作内存（原子性）

     把 x 的值写到y（原子性）

   - i++ 没有原子性

     读 i 到工作空间

     +1

     写 i 到内存

   - z=z+1 没有原子性

     读 z 到工作空间

     +1

     写 z 到内存

   **多个原子性的操作合并到一起没有原子性**

   ****

   - Synchronized

   - JUC Lock

2. **可见性**

   ****

   - volatile:在JMM模型上实现MESI协议
   - Synchronized
   - JUC Lock

3. **有序性**

   ****

   - volatile ：volatile 修饰的变量顺序不变
   - Synchronized ： 加锁的代码顺序不变
   - JUC Lock